```
Network Working Group                                           M. Leech
Request for Comments: 1928                    Bell-Northern Research Ltd
Category: Standards Track                                       M. Ganis
                                         International Business Machines
                                                                  Y. Lee
                                                  NEC Systems Laboratory
                                                                R. Kuris
                                                       Unify Corporation
                                                               D. Koblas
                                                  Independent Consultant
                                                                L. Jones
                                                 Hewlett-Packard Company
                                                              March 1996
```

# SOCKS Protocol Version 5

[RFC1928 原文](https://datatracker.ietf.org/doc/html/rfc1928)

#### 本备忘录的状态

本文档为互联网社区指定了一种互联网标准跟踪协议，并请求讨论和提出改进意见。有关该协议的标准化状态和状态，请参阅《互联网官方协议标准》（STD 1）的最新版本。本备忘录可无限制地分发。


#### 致谢

本备忘录描述了一种协议，这种协议是协议先前版本（版本 4 [1]）的演进。这个新协议源于积极的讨论和原型实现。主要贡献者包括：马库斯·利奇（Marcus Leech）：贝尔-北方研究（Bell-Northern Research），大卫·科布拉斯（David Koblas）：独立顾问，李应达（Ying-Da Lee）：NEC 系统实验室，拉蒙特·琼斯（LaMont Jones）：惠普公司（Hewlett-Packard Company），罗恩·库里斯（Ron Kuris）：Unify 公司，马特·加尼斯（Matt Ganis）：国际商业机器公司（International Business Machines）。

### 1. 引言

网络防火墙的使用越来越受欢迎，这些系统可以有效地将组织的内部网络结构与外部网络（如互联网）隔离开来。这些防火墙系统通常充当网络之间的应用层网关，通常提供受控的 TELNET、FTP 和 SMTP 访问。随着越来越多复杂的应用层协议的出现，这些协议旨在促进全球信息发现，有必要为这些协议提供一个通用框架，以便它们能够透明且安全地穿越防火墙。

此外，还需要以尽可能精细的方式对此类穿越进行强大的身份验证。这一要求源于这样一个认识，即各个组织的网络之间会出现客户端-服务器关系，这些关系需要受到控制，通常需要进行强有力的身份验证。

所描述的协议旨在为TCP和UDP领域中的客户端-服务器应用提供一个框架，以便它们可以方便且安全地使用网络防火墙的服务。该协议在概念上是应用层和传输层之间的“中间层”，因此不提供网络层网关服务，比如转发ICMP消息。

### 2. 现有做法

目前存在一个协议，即 SOCKS 版本 4，它为基于 TCP 的客户端-服务器应用（包括 TELNET、FTP 以及流行的信息发现协议，如 HTTP、WAIS 和 GOPHER）提供了不安全的防火墙穿越。

这个新协议扩展了 SOCKS 版本 4 的模型，以包括 UDP，并扩展了框架，以包含通用的强大身份验证方案，并将寻址方案扩展到涵盖域名和 V6 IP 地址。

实施 SOCKS 协议通常涉及重新编译或重新链接基于 TCP 的客户端应用，以使用 SOCKS 库中的适当封装例程。

注：

除非另有说明，出现在数据包格式图中的十进制数表示相应字段的八位字节长度。当给定的八位字节必须具有特定值时，使用语法 X'hh' 表示该字段中单个八位字节的值。当使用词语“可变”时，它表示相应字段的长度是可变的，可以通过关联的（一个或两个八位字节的）长度字段或数据类型字段来定义。

### 3. 基于TCP的客户端流程

当基于TCP的客户端希望与只能通过防火墙访问的对象建立连接时（此决定由实现确定），它必须打开到SOCKS服务器系统上适当的SOCKS端口的TCP连接。SOCKS服务通常位于TCP端口1080上。如果连接请求成功，客户端会进入用于选择的身份验证方法进行协商，然后使用所选方法进行身份验证，并随后发送中继请求。SOCKS服务器评估请求，要么建立适当的连接，要么拒绝请求。

除非另有说明，出现在数据包格式图中的十进制数字表示相应字段的字节长度。当给定的字节必须具有特定值时，使用语法 X'hh' 表示该字段中单个字节的值。当使用词语“Variable”时，它表示相应字段的长度是可变的，可以通过关联的（一个或两个字节的）长度字段或数据类型字段来定义。

客户端连接到服务器，并发送一个版本标识符/方法选择消息：
  
        +----+----------+----------+
        |VER | NMETHODS | METHODS  |
        +----+----------+----------+
        | 1  |    1     | 1 to 255 |
        +----+----------+----------+

对于这个协议版本，VER字段被设置为X'05'。NMETHODS字段包含了在METHODS字段中出现的方法标识符字节的数量。

服务器从METHODS中选择一种方法，并发送一个方法选择消息：
  
        +----+--------+
        |VER | METHOD |
        +----+--------+
        | 1  |   1    |
        +----+--------+

如果选择的方法是X'FF'，则客户端列出的所有方法都不可接受，客户端必须关闭连接。

目前为METHOD定义的值有：

* X'00' 无需身份验证
* X'01' GSSAPI
* X'02' 用户名/密码
* X'03' 到 X'7F' IANA 分配
* X'80' 到 X'FE' 保留供私有方法使用
* X'FF' 无可接受的方法

然后客户端和服务器进入特定于方法的子协商阶段。

对于方法相关的子协商的描述将在单独的备忘录中提供。

为此协议开发新的METHOD支持的开发者应联系IANA以获取一个METHOD编号。应参考ASSIGNED NUMBERS文档以获取当前METHOD编号及其对应的协议的列表。

符合要求的实现必须支持GSSAPI，并应支持USERNAME/PASSWORD身份验证方法。


### 4. 请求

一旦与方法相关的子协商完成，客户端将发送请求的详细信息。如果协商的方法包括用于完整性检查和/或机密性的封装，这些请求必须在方法相关的封装中进行。

SOCKS请求的构成如下：

        +----+-----+-------+------+----------+----------+
        |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
        +----+-----+-------+------+----------+----------+
        | 1  |  1  | X'00' |  1   | Variable |    2     |
        +----+-----+-------+------+----------+----------+


其中：

* VER 协议版本：X'05'
* CMD
  * CONNECT X'01'
  * BIND X'02'
  * UDP ASSOCIATE X'03'
* RSV 保留字段
* ATYP 后续地址的地址类型
  * IP V4 地址：X'01'
  * 域名：X'03'
  * IP V6 地址：X'04'
* DST.ADDR 期望的目标地址
* DST.PORT 期望的目标端口，以网络字节顺序表示

SOCKS服务器通常会根据源地址和目标地址评估请求，并根据请求类型返回一个或多个回复消息。


### 5. 寻址

在地址字段（DST.ADDR、BND.ADDR）中，ATYP字段指定了该字段内包含的地址类型：

* X'01'：地址是一个长度为4个八位字节的版本4 IP地址。
* X'03'：地址字段包含一个完全限定的域名。地址字段的第一个八位字节包含随后的名称的八位字节数，没有终止的NUL八位字节。
* X'04'：地址是一个长度为16个八位字节的版本6 IP地址。


### 6. 回复

客户端在与SOCKS服务器建立连接并完成身份验证协商后，会立即将SOCKS请求信息发送给服务器。服务器评估请求，并返回一个如下所示的回复：

        +----+-----+-------+------+----------+----------+
        |VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
        +----+-----+-------+------+----------+----------+
        | 1  |  1  | X'00' |  1   | Variable |    2     |
        +----+-----+-------+------+----------+----------+


其中：

* VER 协议版本：X'05'
* REP 回复字段：
    * X'00' 成功
    * X'01' 通用的SOCKS服务器故障
    * X'02' 连接不被规则集允许
    * X'03' 网络不可达
    * X'04' 主机不可达
    * X'05' 连接被拒绝
    * X'06' TTL（生存时间）过期
    * X'07' 命令不支持
    * X'08' 地址类型不支持
    * X'09' 到 X'FF' 未分配
* RSV 保留字段
* ATYP 后续地址的地址类型
    * IP V4 地址：X'01'
    * 域名：X'03'
    * IP V6 地址：X'04'
* BND.ADDR 服务器绑定的地址
* BND.PORT 服务器绑定的端口，以网络字节顺序表示

标记为保留字段（RSV）的字段必须设置为X'00'。

如果所选择的方法包括用于身份验证、完整性和/或机密性的封装，那么回复会在方法相关的封装中进行。


CONNECT

在对CONNECT请求的回复中，BND.PORT包含了服务器分配用于连接到目标主机的端口号，而BND.ADDR包含了相关的IP地址。提供的BND.ADDR通常与客户端用于连接到SOCKS服务器的IP地址不同，因为此类服务器通常具有多个IP地址。预计SOCKS服务器将使用DST.ADDR和DST.PORT，以及客户端侧的源地址和端口来评估CONNECT请求。

BIND

BIND请求用于需要客户端接受来自服务器的连接的协议。FTP是一个著名的例子，它使用主要的客户端到服务器连接进行命令和状态报告，但可能使用服务器到客户端连接根据需要传输数据（例如，LS、GET、PUT）。

预期应用程序协议的客户端仅在使用CONNECT建立主连接后，才会使用BIND请求来建立次要连接。预计SOCKS服务器将使用DST.ADDR和DST.PORT来评估BIND请求。

在BIND操作期间，SOCKS服务器向客户端发送两个回复。第一个回复在服务器创建和绑定新套接字后发送。BND.PORT字段包含SOCKS服务器分配的用于监听传入连接的端口号。BND.ADDR字段包含相关的IP地址。客户端通常会使用这些信息（通过主连接或控制连接）通知应用程序服务器约会地址。第二个回复仅在预期的传入连接成功或失败后发生。

在第二个回复中，BND.PORT和BND.ADDR字段包含连接主机的地址和端口号。

UDP ASSOCIATE

UDP ASSOCIATE请求用于在UDP中继过程中建立关联，以处理UDP数据报。DST.ADDR和DST.PORT字段包含客户端期望用于发送与关联相关的UDP数据报的地址和端口。服务器可以使用这些信息来限制对关联的访问。如果客户端在UDP ASSOCIATE时不具备这些信息，客户端必须使用全部为零的端口号和地址。

UDP关联在接收UDP ASSOCIATE请求的TCP连接终止时终止。

在UDP ASSOCIATE请求的回复中，BND.PORT和BND.ADDR字段指示了客户端必须发送UDP请求消息以进行中继的端口号/地址。


回复处理

当回复（REP值不等于X'00'）指示失败时，SOCKS服务器必须在发送回复后不久终止TCP连接。这必须在检测到导致失败的情况后不超过10秒。

如果回复代码（REP值为X'00'）表示成功，并且请求是BIND或CONNECT，则客户端现在可以开始传递数据。如果所选的身份验证方法支持用于完整性、身份验证和/或机密性的封装，那么数据将使用方法相关的封装进行封装。同样地，当数据到达SOCKS服务器用于客户端时，服务器必须根据正在使用的身份验证方法适当地对数据进行封装。

### 7. 基于UDP的客户端流程

基于UDP的客户端必须将其数据报发送到UDP中继服务器的UDP端口，该端口由UDP ASSOCIATE请求的回复中的BND.PORT指示。如果所选的身份验证方法提供了用于真实性、完整性和/或机密性的封装，那么数据报必须使用适当的封装进行封装。每个UDP数据报都带有一个UDP请求头：

      +----+------+------+----------+----------+----------+
      |RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |
      +----+------+------+----------+----------+----------+
      | 2  |  1   |  1   | Variable |    2     | Variable |
      +----+------+------+----------+----------+----------+

UDP请求头中的字段如下：

- RSV 保留字段，固定为X'0000'
- FRAG 当前分片编号
- ATYP 后续地址的地址类型
  - IP V4 地址：X'01'
  - 域名：X'03'
  - IP V6 地址：X'04'
- DST.ADDR 期望的目标地址
- DST.PORT 期望的目标端口
- DATA 用户数据


当UDP中继服务器决定中继UDP数据报时，它会在没有通知请求客户端的情况下进行静默中继。同样，它将丢弃无法中继的或不打算中继的数据报。当UDP中继服务器从远程主机接收到回复数据报时，它必须使用上述UDP请求头以及任何身份验证方法相关的封装来封装该数据报。

UDP中继服务器必须从SOCKS服务器获取将向在UDP ASSOCIATE的回复中给出的BND.PORT发送数据报的客户端的预期IP地址。它必须丢弃从除了特定关联的记录的IP地址之外的任何源IP地址接收到的数据报。

FRAG字段指示该数据报是否是多个片段中的一个。如果实现了，高位比特表示片段序列的结束，而X'00'的值表示此数据报是独立的。值在1到127之间指示片段在片段序列中的位置。每个接收者将具有与这些片段相关的REASSEMBLY QUEUE和REASSEMBLY TIMER。每当REASSEMBLY TIMER过期或新的数据报到达并携带一个FRAG字段，其值小于已处理的片段序列的最高FRAG值时，必须重新初始化重组队列并放弃相关的片段。重组计时器必须不少于5秒。建议应用程序尽可能避免分段。

分段的实现是可选的；不支持分段的实现必须丢弃FRAG字段不为X'00'的任何数据报。

对于支持SOCKS的UDP的编程接口，必须报告比操作系统提供的实际空间小的可用缓冲区空间，具体规定如下：

- 如果ATYP为X'01'，则要小10+method_dependent个八位字节。
- 如果ATYP为X'03'，则要小262+method_dependent个八位字节。
- 如果ATYP为X'04'，则要小20+method_dependent个八位字节。

这些是可用于UDP数据报的缓冲区的规定大小。其中method_dependent表示具体的方法依赖的额外开销。

### 8. 安全性考虑

本文档描述了一种用于应用层穿越IP网络防火墙的协议。此类穿越的安全性在很大程度上取决于特定实现中提供的特定身份验证和封装方法，并在SOCKS客户端和SOCKS服务器之间的协商过程中选择的方法。

管理员应该仔细考虑选择身份验证方法。不同的身份验证方法会对安全性产生影响，因此需要根据实际情况进行选择。

### 9. 参考文献

[1] Koblas, D.，“SOCKS”，《会议论文集：1992年Usenix安全研讨会》。


Author's Address

       Marcus Leech
       Bell-Northern Research Ltd
       P.O. Box 3511, Stn. C,
       Ottawa, ON
       CANADA K1Y 4H7

       Phone: (613) 763-9145
       EMail: mleech@bnr.ca


-- Translated by chatGPT
